<!DOCTYPE html>
<html>
<head>
    <title>Ingest Bar Chart</title>
    <script src="js/d3.min.js" charset="utf-8"></script>
    <script type="text/javascript" src="js/jquery.min.js"></script>
    <link rel="stylesheet" href="css/custom.min.css" />
    <style type="text/css">
        html, body {
            height: 100%;
        }

        svg {
            font-size: 10px;
        }

        .axis {
            shape-rendering: crispEdges;
        }

            .axis path, .axis line {
                fill: none;
            }

        .x.axis path {
            stroke: #000;
        }

        .y.axis path {
            stroke: #000;
        }

        path.line {
            fill: none;
            stroke: #000;
            stroke-width: .5px;
        }

        rect.pane {
            cursor: e-resize;
            fill: none;
            pointer-events: all;
        }

        #chart-header > span {
            font-size: 14px;
        }

        #chart {
            height: 100%;
        }

        .top30 {
            margin-top: 30px;
        }

        .bar {
            cursor: pointer;
        }

            .bar:hover {
                fill: #00aeef;
            }

        #tooltip {
            color: white;
            opacity: .9;
            background: #53565A;
            padding: 5px;
            border: 1px solid #B1BABF;
            border-radius: 5px;
            position: absolute;
            font-size:14px;
            z-index: 10;
            visibility: hidden;
            white-space: nowrap;
            pointer-events: none;
        }

        @media screen and (max-width:900px){
            #tooltip{
                font-size:12px;
            }
        }

        @media screen and (max-width:800px){
            #tooltip{
                font-size:10px;
            }
        }
    </style>
</head>
<body>
    <div id="tooltip"></div>
    <div class="container-fluid">
        <div class="row">
            <div class="col-md-12 text-center top30" id="chart-header">
                <p id="range"></p>
                <p id="total"></p>
            </div>
            <div class="col-md-12" id="chart">

            </div>
        </div>
    </div>

    <script>

        var x, y, xAxis, yAxis, area, svg, rect, format;
        var intelBlue = "#0071c5";

        function buildGraph() {
            var m = [79, 80, 160, 79], // Margin
                w = document.body.clientWidth - m[1] - m[3],
                parse = d3.time.format("%Y-%m-%d %H:%M").parse;

            var h = 300;

            if (document.body.clientHeight > 300)
                h = document.body.clientHeight;

            h = h - m[0] - m[2],

                format = d3.time.format("%Y-%m-%d %H:%M");

            // Scales. Note the inverted domain for the y-scale: bigger is up!
            x = d3.time.scale().range([0, w]);
            y = d3.scale.linear().range([h, 0]);
            xAxis = d3.svg.axis().scale(x).orient("bottom");
            yAxis = d3.svg.axis().scale(y).orient("left");

            // An area generator.
            //area = d3.svg.area()
            //    //.interpolate("basis")
            //    .x(function (d) {
            //        return x(d.date);
            //    })
            //    .y0(h)
            //    .y1(function (d) { return y(d.flows); });

            //line = d3.svg.line()
            //       .x(function (d) {
            //            return x(d.date);
            //            })
            //        .y(function (d) { return y(d.flows); });

            svg = d3.select("#chart").append("svg:svg")
            .attr("width", w + m[1] + m[3])
            .attr("height", h + m[0] + m[2])
          .append("svg:g")
            .attr("transform", "translate(" + m[3] + "," + m[0] + ")");

            svg.append("svg:clipPath")
                .attr("id", "clip")
              .append("svg:rect")
                .attr("x", x(0))
                .attr("y", y(1))
                .attr("width", x(1) - x(0))
                .attr("height", y(0) - y(1));

            svg.append("svg:g")
                .attr("class", "y axis");

            svg.append("svg:g")
                .attr("class", "x axis")
                .attr("transform", "translate(0," + h + ")");

            rect = svg.append("svg:rect")
                       .attr("class", "pane")
                       .attr("width", w)
                       .attr("height", h);

            d3.csv("dataset/ingest_summary.csv", function (data) {

                // Parse dates and numbers.
                data.forEach(function (d) {
                    d.date = parse(d.date);
                    d.flows = +d.flows;
                });

                x.domain([d3.min(data, function (d) { return d.date; }), d3.max(data, function (d) { return d.date; })]);
                y.domain([0, d3.max(data, function (d) { return d.flows; })]);

                // Bind the data to our path elements.
                //svg.select("path.area").data([data]);

                //svg.select("path.line").data([data]);

                svg.append("g")
                    .attr("class", "bars")
                        .selectAll(".bar")
                        .data(data)
                        .enter().append("rect")
                            .attr("class", "bar")
                            .attr("clip-path", "url(#clip)")
                            .attr("width", 10)
                            .attr("y", function (d) {
                                if (!isNaN(d.flows))
                                    return y(d.flows);
                                else
                                    return 0;
                            })
                            .attr("x", function (d) { return x(d.date) })
                            .attr("height", function (d) {
                                if (!isNaN(d.flows))
                                    return h - y(d.flows);
                                else
                                    return 0;
                            })
                            .attr("fill", intelBlue)
                            .on("mouseover", mouseover)
                            .on("mouseout", function (d) { d3.select("#tooltip").style("visibility", "hidden") });


                rect.call(d3.behavior.zoom().x(x)
                  .scaleExtent([0.3, 2300])
                  .on("zoom", zoom));

                draw();

            });
        }
        function draw() {
            svg.select("g.x.axis").call(xAxis);
            svg.select("g.y.axis").call(yAxis);
            //svg.select("path.area").attr("d", area);
            //svg.select("path.line").attr("d", line);
            var numberFormat = d3.format(",d");
            // this code updates the CX and CY attibutes of the circles so they can move along with the area and the line
            svg.selectAll("rect.bar")
                .attr("x", function (d) { return x(d.date); })
                .attr("y", function (d) {
                    if (!isNaN(d.flows))
                        return y(d.flows);
                    else
                        return 0;
                });

            /*
            svg.selectAll("text.hover")
                .attr("x", function (d) { return x(d.date) + 5; })
                .attr("y", function (d) { return y(d.flows) - 10; });
            */
            d3.select("#range").html("Seeing total flows <strong>from:</strong> " + x.domain().map(format).join(" <strong>to:</strong> "));

            var flowsBetweenRange = $.map(d3.selectAll(".bar").data(), function (obj) {

                if (obj.date >= x.domain()[0] && obj.date <= x.domain()[1]) {
                    return obj.flows;
                }


            });

            var total = 0;

            for (var i = 0; i < flowsBetweenRange.length; i++) {
                if (!isNaN(flowsBetweenRange[i]))
                    total = total + flowsBetweenRange[i];
            }

            d3.select("#total").html("<strong>Total netflows in range:</strong> " + numberFormat(total));


            //rect.style("cursor", "move");
        }

        function zoom() {
            if (d3.event.sourceEvent.type == "wheel") {
                if (d3.event.sourceEvent.wheelDelta < 0)
                    rect.style("cursor", "zoom-out");
                else
                    rect.style("cursor", "zoom-in");
            }
            else if (d3.event.sourceEvent.type == "mousemove") {
                rect.style("cursor", "e-resize");
            }

            draw();
        }

        function barTip(d) {
            var n = d3.format(".2s");
            return "Date: " + " <strong>" + format(d.date) + "</strong><br/>"
            + "Flows:" + " <strong>" + n(d.flows) + "</strong><br/>"
            + "Bytes:" + " <strong>" + n(+d.bytes) + "</strong><br/>"
            + "Packets:" + " <strong>" + n(+d.packets) + "</strong><br/>"
            + "Avg_Bps:" + " <strong>" + n(+d.avg_bps) + "</strong><br/>"
            + "Avg_Pps:" + " <strong>" + n(+d.avg_pps) + "</strong><br/>"
            + "Avg_Bpp:" + " <strong>" + n(+d.avg_bpp) + "</strong>"
        }

        function mouseover(d) {
            d3.select("#tooltip")
              .style("visibility", "visible")
              .html(barTip(d))
              .style("top", function () { return (y(d.flows) + 10) + "px" })
              .style("left", function () { return (d3.event.pageX - 130) + "px"; });
        }

        $(function () {

            buildGraph();

            $(window).resize(function () {
                $('#chart').html("");
                buildGraph();
            });
        });


    </script>
</body>
</html>
